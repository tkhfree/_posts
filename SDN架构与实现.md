---
title: SDN架构与实现
toc: true
thumbnail: 
comments: true
tags:
  - SDN
  - ONOS
date: 2020-06-21 02:22:11
urlname:
categories:
---

# SDN南向编程接口

## 狭义SDN南向编程接口

### **OpenFlow原理**

OpenFlow交换机包括安全通道和流表两部分，流表负责存放流表项；安全通道负责与控制器的通信，可以建立在tcp上，也可以给予TLS加密之后的socket建立。

后续在1.3版本增加了组表和Meter表。

具体流程是：

1. 交换机将自身的状态和端口描述等信息上报给控制器
2. 当有数据通过交换机传输进来时，交换机根据流表项决定怎么处理数据
3. 如果流表项没有匹配到，将数据包放入packet-in报文中上报到控制器，控制器接收到packet-in报文，可以选择下发流表项和下发packet-out报文给交换机告知怎么处理数据流。交换机只是一个策略执行者

### **OpenFlow表**

1. 流表

   Flow Table是交换机存放流表项，多级流表将数据包的处理分解为多个子逻辑，用多张流表来匹配和处理，对数据包的处理编程了流水线。

   流表项由**匹配域、指令集和计数器**三个主要部分和其他部分组成。

   - 匹配域用于区分不同的数据流

     <font color=red>数据流是指数据包进入交换机后匹配流表项，匹配到同一个流表的数据包称为数据流，即Data flow，简写flow</font>

   - 指令集用于决定匹配到的数据流动作

   - 计数器用于统计匹配到流表的数据包数量和自己输等

2. 组表

   Group Table用于定于一组动作，方便流表指令集复用，从而使用组播、负载均衡、容灾备份和聚合。

   比如交换机需要将发送到端口1的标签都弹出VLAN标签，则可以创建一个ALL类型的动作桶，然后将弹出VLAN动作和转发到端口1放入其中，这样所有需要转发到端口1的流表项的动作集之需要跳转到对应的组表项，然后执行组表项内全部的动作桶动作。

   组表存在降低流表的逻辑复杂度和减少存储空间

3. Meter表

   Meter Table用于计量和限速。可以针对流制定对应的限速等规则

### **OpenFlow通道**

安全通道是交换机与控制器通信的通道，通道转发的数据为OpenFlow消息/报文。OpenFlow报文为Controller-to-Switch、Asynchronous和Symmetric三大类。Controller-to-Swtich是控制器初始化发送给交换机，Asynchronous是交换机异步上报给控制器的报文、Symmetric是无须等待对方请求，双发都可以任意发送的报文。

1. Controller-to-Switch报文类型
   - Features：控制器主动发送Feature_request报文，要求交换机回复特性信息，报文只有数据报头（Head），没有消息体（body）。交换机在收到Feature_request报文后通过Feature_reply报文回复交换机的特性和交换机端口的特性。
   - Configuration：包含请求、回复、设置三种报文。控制器可以设置和请求交换机的配置信息，交换机则需执行配置和回复配置报文。
   - Modify-State：修改状态型报文，用于修改交换机的流表、组表、Meter表及端口状态
   - Read-State：读取状态信息，用于获取交换机的状态信息，包括流表、组表、Meter表及端口状态
   - Packet-out：响应Packet-in报文
   - Barrier
   - Role-Request
   - Asynchronous-Configuration
2. Asynchronous
3. Symmetric

## 广义SDN南向编程接口

OF-config

OVSdb

NETCONF

XMPP

PCEP

OpFlex

## 完全可编程南向编程接口

### POF

华为提出的采用{offset,length}来定位数据，执行操作，取代了OpenFlow匹配域的限制，对于新协议支持更加灵活

## P4

Openflow只能在已经固化的交换机逻辑上通过流表项指导数据的处理，没有办法重新定义处理数据的逻辑，对于新协议的支持缺乏灵活性。

# SDN控制平面

### OpenDayLight

### ONOS

# SDN数据平面

## 通用可编程转发模型

主要包括通用硬件模型和通用处理指令。通用硬件模型包括一系列通用硬件子模型，通用处理指令包括用户可编程的网络处理操作和控制指令

### 通用硬件模型

网络处理流程：首先数据包从端口进入，通过协议解析模块进行头部解析，根据解析结果选择对应的流表进行处理，在选择的流表中数据包的内容与流表项进行一一匹配，匹配到的执行对应的action，没有匹配到的再按照特定指令进行处理，比如丢弃或者转发给控制器。

#### 流表抽象子模型

每个流表项对应一个流Flow，流的定义是对应于匹配域相同的同一个流表去处理的数据包。例如浏览网页和看视频的数据包，不同网络地址发来的数据包，从应用级、会话级、用户级等颗粒度管理网络策略

流表项的主要内容：

|                        匹配域                        |                 Instructions                 |     计数器     |       优先级       | cookie | flags |
| :--------------------------------------------------: | :------------------------------------------: | :------------: | :----------------: | :----: | :---: |
| 包括输入端口、包头标示域（五元组/vlan id）、metadata | 指定数据包的跳转操作，也包括操作指令集的操作 | 统计数据流信息 | 数值越高优先级越高 |        |       |

OpenFlow Switch需要从数据包中提取协议字段组合，再加上上一个流表的metadata信息共同组建一个待匹配域。然后将待匹配域与当前流表的流表项进行比较。

#### 组表抽象子模型

组表也是一种转发表，具有给某个端口指定某种操作的抽象能力。组表由多个组表项组成，用户通过编程来定义这组端口及要执行的操作。通过在流表项使用Group动作可以将Flow数据包指向某个组操作，从而执行组表中的动作集合。

组表的表项组成：

| Group Identifier |                       Group Type                        | Counters | Action Buckets |
| :--------------: | :-----------------------------------------------------: | :------: | :------------: |
|      id标示      | 必须支持：all、indirect/可选支持：select、fast failover |   计数   |  操作顺序列表  |

#### Meter表抽象子模型

可以用来测量和控制某个Flow的传输速率

#### 状态信息表抽象子模型

多个计数器组合构成了网络状态信息表，包括流表、流表项、端口、队列、Group、Group Bucket、Meter、Duration计数器等。Duration计数器统计流表项、端口、队列、Group、Meter的存活时间。

#### 端口子模型

只有这三种标准端口才能作为输出、输入端口，才能在流表中使用，才能具有端口计数器和端口状态、配置信息

物理端口：真实网络接口，与网络设备中的物理接口一一对应

逻辑端口：抽象的逻辑端口，用来描述链路聚合组、隧道、环回接口等逻辑

保留端口：预留的虚拟端口类型

保留端口类型：

|    名称    |                         description                          |
| :--------: | :----------------------------------------------------------: |
|    All     |    转发数据包到所有端口，只能作为输出端口，数据包会被复制    |
| Controller |                  控制通道，可作为输入/输出                   |
|   Table    | 通用转发模型处理流水线的起始位置，表示将数据包交给流水线的第一个流表来处理 |
|  IN_port   | 描述数据包的输入端口，只能作为输出端口，将数据包发送到自己的输入端口 |
|    Any     | 没有制定端口类型时使用的端口类型，不能用做输入端口和输出端口 |
|   Local    | 描述通用转发模型本地的网络栈和管理栈，可用做输入和输出端口。使得远端设备可以通过OpenFlow网络与通用转发模型交互，使用其网络服务，而不是通过一个独立的控制网络。结合流表项可以实现带内控制器链接 |
|   Normal   |       描述传统的非OpenFlow转发处理流水线，用作输出端口       |
|   Flood    | 传统数据平面的泛洪操作，转发数据包到不包括输入端口和OFPPS_BLOCKED状态的其他所有端口，只能用做输出端口 |

### 通用处理指令

#### 网络处理控制指令Instructions

基于Flow的网络处理流程控制指令Instructions，这种指令可以控制数据包在通用硬件模型流水线上的处理流程。包括两类：第一类是对Flow数据包的操作指令集进行写入、应用或者删除，比如write-actions、Apply-actions。第二类指令是指定Flow数据包在多个表中的处理顺序的跳转指令，比如GOTO-Table。

|    控制指令    | description |
| :------------: | :---------: |
|  apply-action  |             |
|  clear-action  |             |
|  write-action  |             |
| write-metadata |             |
|   goto-table   |             |

每个流表项都可以存在多个控制指令，这些控制指令组合成一个对应的指令集合，实际需要按照上面列出的顺序执行控制指令

#### 操作指令

基于Flow的网络处理操作指令Actions，这种指令完成对数据包的丢弃、转发、复制、修改等操作。每一个数据包在进入流水线时都被分配一个action set，用于保存处理数据的动作，其集合是一个Set，集合中只能存在一个同一类型动作，此外OpenFlow Swtich还定义了一个Action List，List集合可以允许重复的类型动作。

|     操作指令      | Description |
| :---------------: | :---------: |
|  Output port no   |             |
|  Group Group ID   |             |
|       Drop        |             |
| Set-Queue queueid |             |
|  Meter meter id   |             |
| Push-tag/Pop-tag  |             |
|     Set-Field     |             |
|    Copy-Field     |             |
|    change-TTL     |             |

当数据包到达通用硬件模型时，OpenFlow Swtich模型会给数据包分配空的操作指令集，当经过流表时，通过流表的Instruction控制指令完成对操作指令集的添加、删除、更新等。

#### 专用指令

Table-miss定义了在流表中匹配不成功的处理网络数据包的行为

# SDN实验工具

### Cbench

测试控制器性能的工具，Cbench可以模拟一系列软件交换机，然后向控制器发送OFP_Packet_In消息，从而测试控制器处理Packet_in消息的吞吐量和时延

### OFTest

测试OpenFlow协议完整性的工具

### wireshark

网络数据包分析

### 发包工具

#### Iperf

是一个数据包生成工具，可以向网络中打入TCP/SCTP、UDP等数据流量。

Iperf测试模型由服务端和客户端两种角色，测试时由客户端发起数据传输，将数据发向服务端，进而得到带宽数据。

Iperf -s启动服务端 Iperf -c启动客户端

#### Scapy，不是Scrapy

可以构建多种协议数据包

进入scapy

```shell
scapy
```

在交互CLI输入

```shell
eth=ETHER()
ip=IP(dst="8.8.8.8")
tcp=TCP(dport=8080)
pay("i am Mr.Test")
packet=eth/ip/tcp/pay
send(packet)
```

