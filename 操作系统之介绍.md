---
title: 操作系统之介绍
tags:
  - OS
comments: true
toc: true
mathjax: true
date: 2020-07-08 14:35:35
urlname:
categories:
thumbnail:
---

# 计算机硬件系统

操作系统与运行操作系统的内核硬件关系密切。操作系统扩展了计算机指令集并管理计算机的资源。

## CPU

每个 CPU 都有一组可以执行的特定指令集。因此，x86 的 CPU 不能执行 ARM 的程序并且 ARM 的 CPU 也不能执行 x86 的程序。由于访问内存获取执行数据要比执行指令花费的时间长，因此所有的 CPU 内部都会包含一些`寄存器`来保存关键变量和临时结果。因此，在指令集中通常会有一些指令用于把关键字从内存中加载到寄存器中，以及把关键字从寄存器存入到内存中。还有一些其他的指令会把来自寄存器和内存的操作数进行组合，例如 add 操作就会把两个操作数相加并把结果保存到内存中。

除了用于保存变量和临时结果的通用寄存器外，大多数计算机还具有几个特殊的寄存器，这些寄存器对于程序员是可见的。其中之一就是 `程序计数器(program counter)`，程序计数器会指示下一条需要从内存提取指令的地址。提取指令后，程序计数器将更新为下一条需要提取的地址。

另一个寄存器是 `堆栈指针(stack pointer)`，它指向内存中当前栈的顶端。堆栈指针会包含输入过程中的有关参数、局部变量以及没有保存在寄存器中的临时变量。

还有一个寄存器是 `PSW(Program Status Word)` 程序状态字寄存器，这个寄存器是由操作系统维护的8个字节(64位) long 类型的数据集合。它会跟踪当前系统的状态。除非发生系统结束，否则我们可以忽略 PSW 。用户程序通常可以读取整个PSW，但通常只能写入其某些字段。PSW 在系统调用和 I / O 中起着重要作用。

操作系统必须了解所有的寄存器。在`时间多路复用(time multiplexing)` 的 CPU 中，操作系统往往停止运行一个程序转而运行另外一个。每次当操作系统停止运行一个程序时，操作系统会保存所有寄存器的值，以便于后续重新运行该程序。

为了提升性能， CPU 设计人员早就放弃了同时去读取、解码和执行一条简单的指令。许多现代的 CPU 都具有同时读取多条指令的机制。例如**，一个 CPU 可能会有单独访问、解码和执行单元，所以，当 CPU 执行第 N 条指令时，还可以对 N + 1 条指令解码，还可以读取 N + 2 条指令。像这样的组织形式被称为 `流水线(pipeline)。`**

除了用在嵌入式系统中非常简单的 CPU 之外，多数 CPU 都有`两种模式`，即前面已经提到的内核态和用户态。通常情况下，`PSW 寄存器`中的一个二进制位会控制当前状态是内核态还是用户态。当运行在内核态时，CPU 能够执行任何指令集中的指令并且能够使用硬件的功能。在台式机和服务器上，操作系统通常以内核模式运行，从而可以访问完整的硬件。在大多数嵌入式系统中，一部分运行在内核态下，剩下的一部分运行在用户态下。

用户应用程序通常运行在用户态下，在用户态下，CPU 只能执行指令集中的一部分并且只能访问硬件的一部分功能。一般情况下，在用户态下，有关 I/O 和内存保护的所有指令是禁止执行的。当然，设置 PSW 模式的二进制位为内核态也是禁止的。

为了获取操作系统的服务，用户程序必须使用 `系统调用(system call)`，系统调用会转换为内核态并且调用操作系统。`TRAP` 指令用于把用户态切换为内核态并启用操作系统。当有关工作完成之后，在系统调用后面的指令会把控制权交给用户程序。

需要注意的是操作系统在进行系统调用时会存在陷阱。大部分的陷阱会导致硬件发出警告，比如说试图被零除或浮点下溢等你。在所有的情况下，操作系统都能得到控制权并决定如何处理异常情况。有时，由于出错的原因，程序不得不停止。

多线程允许 CPU 保持两个不同的线程状态并且在`纳秒级(nanosecond)` 的时间完成切换。线程是一种轻量级的进程，我们会在后面说到。例如，如果一个进程想要从内存中读取指令(这通常会经历几个时钟周期)，多线程 CPU 则可以切换至另一个线程。多线程不会提供真正的并行处理。在一个时刻只有一个进程在运行。

对于操作系统来讲，多线程是有意义的，因为每个线程对操作系统来说都像是一个单个的 CPU。比如一个有两个 CPU 的操作系统，并且每个 CPU 运行两个线程，那么这对于操作系统来说就可能是 4 个 CPU。

## 内存（存储器）

一般来说高速缓存器使用SRAM；内存使用DRAM；硬盘使用磁盘或者SSD。

计算机中第二个主要的组件就是内存。理想情况下，内存应该非常快速(比执行一条指令要快，从而不会拖慢 CPU 执行效率)，而且足够大且便宜，但是目前的技术手段无法满足三者的需求。于是采用了不同的处理方式，存储器系统采用一种分层次的结构

顶层的存储器速度最高，但是容量最小，成本非常高，层级结构越向下，其访问效率越慢，容量越大，但是造价也就越便宜：

### 寄存器

存储器的顶层是 CPU 中的`寄存器`，它们用和 CPU 一样的材料制成，所以和 CPU 一样快。程序必须在软件中自行管理这些寄存器（即决定如何使用它们）

### 高速缓存

位于寄存器下面的是`高速缓存`，它多数由硬件控制。主存被分割成`高速缓存行(cache lines)` 为 64 字节，内存地址的 0 - 63 对应高速缓存行 0 ，地址 64 - 127 对应高速缓存行的 1，等等。使用最频繁的高速缓存行保存在位于 CPU 内部或非常靠近 CPU 的高速缓存中。当应用程序需要从内存中读取关键词的时候，高速缓存的硬件会检查所需要的高速缓存行是否在高速缓存中。如果在的话，那么这就是`高速缓存命中(cache hit)`。高速缓存满足了该请求，并且没有通过总线将内存请求发送到主内存。高速缓存命中通常需要花费两个时钟周期。缓存未命中需要从内存中提取，这会消耗大量的时间。高速缓存行会限制容量的大小因为它的造价非常昂贵。有一些机器会有两个或者三个高速缓存级别，每一级高速缓存比前一级慢且容量更大。

缓存在计算机很多领域都扮演了非常重要的角色，不仅仅是 RAM 缓存行。

缓存是解决问题的一种好的方式，所以现代 CPU 设计了两种缓存。第一级缓存或者说是 `L1 cache` 总是位于 CPU 内部，**用来将已解码的指令调入 CPU 的执行引擎**。对于那些频繁使用的关键字，多数芯片有第二个 L1 cache 。典型的 L1 cache 的大小为 16 KB。另外，往往还设有二级缓存，也就是 `L2 cache`，用来存放最近使用过的关键字，一般是兆字节为单位。L1 cache 和 L2 cache 最大的不同在于是否存在延迟。访问 L1 cache 没有任何的延迟，然而访问 L2 cache 会有 1 - 2 个时钟周期的延后。

>什么是时钟周期？计算机处理器或 CPU 的速度由时钟周期来确定，该时钟周期是振荡器两个脉冲之间的时间量。一般而言，每秒脉冲数越高，计算机处理器处理信息的速度就越快。时钟速度以 Hz 为单位测量，通常为兆赫（MHz）或千兆赫（GHz）。例如，一个4 GHz处理器每秒执行4,000,000,000个时钟周期。
>
>计算机处理器可以在每个时钟周期执行一条或多条指令，这具体取决于处理器的类型。早期的计算机处理器和较慢的 CPU 在每个时钟周期只能执行一条指令，而现代处理器在每个时钟周期可以执行多条指令。

### 主存(内存RAM)

在上面的层次结构中再下一层是`主存`，这是内存系统的主力军，主存通常叫做 `RAM(Random Access Memory)`

所有不能再高速缓存中得到满足的内存访问请求都会转往主存中

除了主存之外，许多计算机还具有少量的非易失性随机存取存储器。它们与 RAM 不同，在电源断电后，非易失性随机访问存储器并不会丢失内容，就是**闪存**，例如u盘，固态硬盘。`ROM(Read Only Memory)` 中的内容一旦存储后就不会再被修改。它非常快而且便宜。（如果有人问你，有没有什么又快又便宜的内存设备，那就是 ROM 了）在计算机中，用于启动计算机的引导加载模块（也就是 bootstrap ）就存放在 ROM 中。另外，一些 I/O 卡也采用 ROM 处理底层设备控制。

### 磁盘

下一个层次是`磁盘(硬盘)`，磁盘同 RAM 相比，每个二进制位的成本低了两个数量级，而且经常也有两个数量级大的容量。磁盘唯一的问题是随机访问数据时间大约慢了三个数量级。磁盘访问慢的原因是因为磁盘的构造不同

磁盘是一种机械装置，在一个磁盘中有一个或多个金属盘片，它们以 5400rpm、7200rpm、10800rpm 或更高的速度旋转。从边缘开始有一个机械臂悬横在盘面上，这类似于老式播放塑料唱片 33 转唱机上的拾音臂。信息会写在磁盘一系列的同心圆上。在任意一个给定臂的位置，每个磁头可以读取一段环形区域，称为`磁道(track)`。把一个给定臂的位置上的所有磁道合并起来，组成了一个`柱面(cylinder)`。

每个磁道划分若干扇区，扇区的值是 512 字节。在现代磁盘中，较外部的柱面比较内部的柱面有更多的扇区。机械臂从一个柱面移动到相邻的柱面大约需要 1ms。而随机移到一个柱面的典型时间为 5ms 至 10ms，具体情况以驱动器为准。一旦磁臂到达正确的磁道上，驱动器必须等待所需的扇区旋转到磁头之下，就开始读写，低端硬盘的速率是`50MB/s`，而高速磁盘的速率是 `160MB/s`。

> 需要注意，`固态硬盘(Solid State Disk, SSD)`不是磁盘，固态硬盘并没有可以移动的部分，外形也不像唱片，并且数据是存储在`存储器（闪存）`中，与磁盘唯一的相似之处就是它也存储了大量即使在电源关闭也不会丢失的数据。

许多计算机支持一种著名的`虚拟内存`机制，这种机制使得期望运行的存储空间大于实际的物理存储空间。其方法是将程序放在磁盘上，而将主存作为一部分缓存，用来保存最频繁使用的部分程序，这种机制需要快速映像内存地址，用来把程序生成的地址转换为有关字节在 RAM 中的物理地址。这种映像由 CPU 中的一个称为 `存储器管理单元(Memory Management Unit, MMU)` 的部件来完成。

缓存和 MMU 的出现是对系统的性能有很重要的影响，在多道程序系统中，从一个程序切换到另一个程序的机制称为 `上下文切换(context switch)`，对来自缓存中的资源进行修改并把其写回磁盘是很有必要的。

存储器层次结构从上到下：

CPU寄存器（与CPU同样的材质，cpu可以直接读取） -->L0高速缓冲（SRAM，通常需要几个时钟周期）-->L1高速缓存 -->L2高速缓存 -->主存（内存，采用DRAM） -->本地磁盘 -->远程磁盘

每层存储结构都是作为下一层的缓存。

**什么是缓存？**

在K+1层的存储器被划分为连续的数据对象组块(chunk)，称为块（block）。每个块都有一个唯一的地址或者名字，块是固定大小的，也可以是可变大小。类似的在K层的存储器被划分成较少的块的集合，块大小与K+1层一样，K层的缓存就是K+1层部分块的副本。

在相邻的两个存储层次之间的块是一致的，但是与其他层次之间可以有不同的块大小。例如L0与L1层之间的块是几个字节大小，而L1和L2之间的块就是几十个字节大小。

1. 缓存命中cache hit

   如果cpu需要取K+1层里面的数据时，它会先在K层寻找副本，如果找到就是缓存命中。

2. 缓存不命中cache kiss

   如果K层没有缓存需要的数据，这就是缓存不命中。K层会从K+1层中取出需要的缓存，如果K层存储满了，就会覆盖一个块，这叫做替换或者驱逐，被替换掉的叫牺牲块，替换哪一个有替换策略控制

3. 缓存不命中的种类包括：冷不命中和冲突不命中

   冷不命中：就是K层缓存块里没有缓存任何数据

   冲突不命中：在K层缓存的时候并不是随意缓存下一层的数据，而是有一个放置策略，例如K层 **i** 缓存块只会缓存下一层被4整除的数据块，则**i**缓存的就是0、4、8、12块等，如果在程序执行过程中，有一个循环，不停的访问一个数组，这个数组比较大，分放在K+1存储器4、8两个块内，则在K层只会缓存4或者8其中的一个，就会造成不停的缓存不命中，这就是冲突不命中。这很明显就是缓存块设置的太小，像DPDK里面的改进就是有一项大页设置，设置比较大的缓存块。

4. 缓存管理

   设立存储器结构层次就是为了缓存下一层存储器，因此必须有某种逻辑管理缓存，具体就是划分成块，传送块，判断是否命中，并处理。处理逻辑可以是硬件也可以是软件。

   编译器管理寄存器文件。

   L1、L2、L3是由内置在缓存中的硬件逻辑来管理。

   在使用虚拟内存（基本现在操作系统都使用）的系统里，DRAM内存是作为磁盘上数据块的缓存，由操作系统软件和CPU内地址翻译寄存器TLB的硬件共同管理。

   本次磁盘缓存远程磁盘的缓存管理由像AFS这样的分布式文件系统

## I/O 设备

I/O 设备一般包括两个部分：设备控制器和设备本身。控制器本身是一块芯片或者一组芯片，它能够控制物理设备。它能够接收操作系统的指令，例如，从设备中读取数据并完成数据的处理。

在许多情况下，实际控制设备的过程是非常复杂而且存在诸多细节。因此控制器的工作就是为操作系统提供一个更简单（但仍然非常复杂）的接口。也就是屏蔽物理细节。**任何复杂的东西都可以加一层代理来解决，这是计算机或者人类社会很普世的一个解决方案**

I/O 设备另一部分是设备本身，设备本身有一个相对简单的接口，这是因为接口既不能做很多工作，而且也已经被标准化了。例如，标准化后任何一个 SATA 磁盘控制器就可以适配任意一种 SATA 磁盘，所以标准化是必要的。`ATA` 代表 `高级技术附件(AT Attachment)`，而 SATA 表示`串行高级技术附件(Serial ATA)`。

现在 SATA 是很多计算机的标准硬盘接口。由于实际的设备接口隐藏在控制器中，所以操作系统看到的是对控制器的接口，这个接口和设备接口有很大区别。

每种类型的设备控制器都是不同的，所以需要不同的软件进行控制。专门与控制器进行信息交流，发出命令处理指令接收响应的软件，称为 `设备驱动程序(device driver)`。每个控制器厂家都应该针对不同的操作系统提供不同的设备驱动程序。

为了使设备驱动程序能够工作，必须把它安装在操作系统中，这样能够使它在内核态中运行。

每个设备控制器都有少量用于通信的寄存器，例如，一个最小的磁盘控制器也会有用于指定磁盘地址、内存地址、扇区计数的寄存器。要激活控制器，设备驱动程序会从操作系统获取一条指令，然后翻译成对应的值，并写入设备寄存器中，所有设备寄存器的结合构成了 `I/O 端口空间` 。

- 在最简单的方式中，用户程序会发起系统调用，内核会将其转换为相应驱动程序的程序调用，然后设备驱动程序启动 I/O 并循环检查该设备，看该设备是否完成了工作（一般会有一些二进制位用来指示设备仍在忙碌中）。当 I/O 调用完成后，设备驱动程序把数据送到指定的地方并返回。然后操作系统会将控制权交给调用者。这种方式称为 `忙等待(busy waiting)`，这种方式的缺点是要一直占据 CPU，CPU 会一直轮询 I/O 设备直到 I/O 操作完成。

- 第二种方式是设备驱动程序启动设备并且让该设备在操作完成时发生中断。设备驱动程序在这个时刻返回。操作系统接着在需要时阻塞调用者并安排其他工作进行。当设备驱动程序检测到该设备操作完成时，它发出一个 `中断` 通知操作完成。

  ![](https://pic.downk.cc/item/5f0591ad14195aa59409cb8f.png)

  如上图所示，这是一个三步的 I/O 过程，第一步，设备驱动程序会通过写入设备寄存器告诉控制器应该做什么。然后，控制器启动设备。当控制器完成读取或写入被告知需要传输的字节后，它会在步骤 2 中使用某些总线向中断控制器发送信号。如果中断控制器准备好了接收中断信号（如果正忙于一个优先级较高的中断，则可能不会接收），那么它就会在 CPU 的一个引脚上面声明。这就是步骤3

  在第四步中，中断控制器把该设备的编号放在总线上，这样 CPU 可以读取总线，并且知道哪个设备完成了操作（可能同时有多个设备同时运行）。

  一旦 CPU 决定去实施中断后，程序计数器和 PSW 就会被压入到当前堆栈中并且 CPU 会切换到内核态。设备编号可以作为内存的一个引用，用来寻找该设备中断处理程序的地址。这部分内存称作`中断向量(interrupt vector)`。一旦中断处理程序（中断设备的设备驱动程序的一部分）开始后，它会移除栈中的程序计数器和 PSW 寄存器，并把它们进行保存，然后查询设备的状态。在中断处理程序全部完成后，它会返回到先前用户程序尚未执行的第一条指令

- 实现 I/O 的第三种方式是使用特殊的硬件：`直接存储器访问(Direct Memory Access, DMA)` 芯片。它可以控制内存和某些控制器之间的位流，而无需 CPU 的干预。CPU 会对 DMA 芯片进行设置，说明需要传送的字节数，有关的设备和内存地址以及操作方向。当 DMA 芯片完成后，会造成中断，中断过程就像上面描述的那样。我们会在后面具体讨论中断过程

当另一个中断处理程序正在运行时，中断可能（并且经常）发生在不合宜的时间。因此，CPU 可以禁用中断，并且可以在之后重启中断。在 CPU 关闭中断后，任何已经发出中断的设备，可以继续保持其中断信号处理，但是 CPU 不会中断，直至中断再次启用为止。如果在关闭中断时，已经有多个设备发出了中断信号，中断控制器将决定优先处理哪个中断，通常这取决于事先赋予每个设备的优先级，最高优先级的设备优先赢得中断权，其他设备则必须等待。

## 总线

随着处理器核内存变得越来越快，单个总线处理所有请求的能力也达到了上线，其中也包括 IBM PC 总线。必须放弃使用这种模式。其结果导致了其他总线的出现，它们处理 I/O 设备以及 CPU 到存储器的速度都更快。这种演变的结果导致了下面这种结构的出现。

![](https://pic.downk.cc/item/5f05931814195aa5940a66bc.jpg)

上图中的 x86 系统包含很多总线，**高速缓存、内存、PCIe、PCI、USB、SATA 和 DMI**，每条总线都有不同的传输速率和功能。操作系统必须了解所有的总线配置和管理。其中最主要的总线是 `PCIe(Peripheral Component Interconnect Express)` 总线。

Intel 发明的 PCIe 总线也是作为之前古老的 PCI 总线的继承者，而古老的 PCI 总线也是为了取代古董级别的 `ISA(Industry Standard Architecture)` 总线而设立的。数十 Gb/s 的传输能力使得 PCIe 比它的前身快很多，而且它们本质上也十分不同。直到发明 PCIe 的 2004 年，大多数总线都是并行且共享的。`共享总线架构(shared bus architeture)` 表示多个设备使用一些相同的电线传输数据。因此，当多个设备同时发送数据时，此时你需要一个决策者来决定谁能够使用总线。而 PCIe 则不一样，它使用专门的端到端链路。传统 PCI 中使用的`并行总线架构(parallel bus architecture)` 表示通过多条电线发送相同的数据字。例如，在传统的 PCI 总线上，一个 32 位数据通过 32 条并行的电线发送。而 PCIe 则不同，它选用了`串行总线架构(serial bus architecture)` ，并通过单个连接（称为通道）发送消息中的所有比特数据，就像网络数据包一样。这样做会简化很多，因为不再确保所有 32 位数据在同一时刻准确到达相同的目的地。通过将多个数据通路并行起来，并行性仍可以有效利用。例如，可以使用 32 条数据通道并行传输 32 条消息。

在上图结构中，CPU 通过 DDR3 总线与内存对话，通过 PCIe 总线与外围图形设备 （GPU）对话，通过 `DMI(Direct Media Interface)`总线经集成中心与所有其他设备对话。而集成控制中心通过串行总线与 USB 设备对话，通过 SATA 总线与硬盘和 DVD 驱动器对话，通过 PCIe 传输以太网络帧。

## 计算机启动过程

那么有了上面一些硬件再加上操作系统的支持，我们的计算机就可以开始工作了，那么计算机的启动过程是怎样的呢？下面只是一个简要版的启动过程

在每台计算机上有一块双亲板，也就是母板，母板也就是主板，它是计算机最基本也就是最重要的部件之一。主板一般为矩形电路板，上面安装了组成计算机的主要电路系统，一般有 BIOS 芯片、I/O 控制芯片、键盘和面板控制开关接口、指示灯插接件、扩充插槽、主板及插卡的直流电源供电接插件等元件。

在母板上有一个称为 `基本输入输出系统(Basic Input Output System, BIOS)`的程序。在 BIOS 内有底层 I/O 软件，包括读键盘、写屏幕、磁盘I/O 以及其他过程。如今，它被保存在闪存中，它是非易失性的，但是当BIOS 中发现错误时，可以由操作系统进行更新。

在计算机`启动(booted)`时，BIOS 开启，它会首先检查所安装的 RAM 的数量，键盘和其他基础设备是否已安装并且正常响应。接着，它开始扫描 PCIe 和 PCI 总线并找出连在上面的所有设备。即插即用的设备也会被记录下来。如果现有的设备和系统上一次启动时的设备不同，则新的设备将被重新配置。

然后，BIOS 通过尝试存储在 `CMOS` 存储器中的设备清单尝试启动设备

用户可以在系统启动后进入一个 BIOS 配置程序，对设备清单进行修改。然后，判断是否能够从外部 `CD-ROM` 和 USB 驱动程序启动，如果启动失败的话（也就是没有），系统将从硬盘启动，boots 设备中的第一个扇区被读入内存并执行。该扇区包含一个程序，该程序通常在引导扇区末尾检查分区表以确定哪个分区处于活动状态。然后从该分区读入第二个启动加载程序，该加载器从活动分区中读取操作系统并启动它。

然后操作系统会询问 BIOS 获取配置信息。对于每个设备来说，会检查是否有设备驱动程序。如果没有，则会向用户询问是否需要插入 `CD-ROM` 驱动（由设备制造商提供）或者从 Internet 上下载。一旦有了设备驱动程序，操作系统会把它们加载到内核中，然后初始化表，创建所需的后台进程，并启动登录程序或GUI。

# 操作系统概念

## 进程

操作系统一个很关键的概念就是 `进程(Process)`。进程的本质就是操作系统执行的一个程序。与每个进程相关的是`地址空间(address space)`，这是从某个最小值的存储位置(通常是零)到某个最大值的存储位置的列表。在这个地址空间中，进程可以进行读写操作。地址空间中存放有可执行程序，程序所需要的数据和它的栈。与每个进程相关的还有资源集，通常包括`寄存器(registers)`（寄存器一般包括`程序计数器(program counter)`和`堆栈指针(stack pointer)`）、打开文件的清单、突发的报警、有关的进程清单和其他需要执行程序的信息。你可以把进程看作是容纳运行一个程序所有信息的一个容器。

对进程建立一种直观感觉的方式是考虑建立一种多程序的系统。考虑下面这种情况：用户启动一个视频编辑程序，指示它按照某种格式转换视频，然后再去浏览网页。同时，一个检查电子邮件的后台进程被唤醒并开始运行，这样，我们目前就会有三个活动进程：视频编辑器、Web 浏览器和电子邮件接收程序。操作系统周期性的挂起一个进程然后启动运行另一个进程，这可能是由于过去一两秒钟程序用完了 CPU 分配的时间片，而 CPU 转而运行另外的程序。

像这样暂时中断进程后，下次应用程序在此启动时，必须要恢复到与中断时刻相同的状态，这在我们用户看起来是习以为常的事情，但是操作系统内部却做了巨大的事情。**这就像和足球比赛一样，一场完美精彩的比赛是可以忽略裁判的存在的**。这也意味着在挂起时该进程的所有信息都要被保存下来。例如，进程可能打开了多个文件进行读取。与每个文件相关联的是提供当前位置的指针（即下一个需要读取的字节或记录的编号）。当进程被挂起时，必须要保存这些指针，以便在重新启动进程后执行的 `read`调用将能够正确的读取数据。在许多操作系统中，与一个进程有关的所有信息，除了该进程自身地址空间的内容以外，均存放在操作系统的一张表中，称为 `进程表(process table)`，进程表是数组或者链表结构，当前存在每个进程都要占据其中的一项。

所以，一个挂起的进程包括：进程的地址空间（往往称作`磁芯映像`， core image，纪念过去的磁芯存储器），以及对应的进程表项（其中包括寄存器以及稍后启动该进程所需要的许多其他信息）。

与进程管理有关的最关键的系统调用往往是决定着进程的创建和终止的系统调用。考虑一个典型的例子，有一个称为 `命令解释器(command interpreter)` 或 `shell` 的进程从终端上读取命令。此时，用户刚键入一条命令要求编译一个程序。shell 必须先创建一个新进程来执行编译程序，当编译程序结束时，它执行一个系统调用来终止自己的进程。

如果一个进程能够创建一个或多个进程（称为`子进程`），而且这些进程又可以创建子进程，则很容易找到进程数

合作完成某些作业的相关进程经常需要彼此通信来完成作业，这种通信称为`进程间通信(interprocess communication)`。我们在后面会探讨进程间通信。

有时，需要向一个正在运行的进程传递信息，而该进程并没有等待接收信息。例如，一个进程通过网络向另一台机器上的进程发送消息进行通信。为了保证一条消息或消息的应答不丢失。发送者要求它所在的操作系统在指定的若干秒后发送一个通知，这样如果对方尚未收到确认消息就可以进行重新发送。在设定该定时器后，程序可以继续做其他工作。

在限定的时间到达后，操作系统会向进程发送一个 `警告信号(alarm signal)`。这个信号引起该进程暂时挂起，无论该进程正在做什么，系统将其寄存器的值保存到堆栈中，并开始重新启动一个特殊的信号处理程，比如重新发送可能丢失的消息。这些信号是软件模拟的硬件中断，除了定时器到期之外，该信号可以通过各种原因产生。许多由硬件检测出来的陷阱，如执行了非法指令或使用了无效地址等，也被转换成该信号并交给这个进程。

系统管理器授权每个进程使用一个给定的 `UID(User IDentification)`。每个启动的进程都会有一个操作系统赋予的 UID，子进程拥有与父进程一样的 UID。用户可以是某个组的成员，每个组也有一个 `GID(Group IDentification)`。

在 UNIX 操作系统中，有一个 UID 是 `超级用户(superuser)`，或者 Windows 中的`管理员(administrator)`，它具有特殊的权利，可以违背一些保护规则。在大型系统中，只有系统管理员掌握着那些用户可以称为超级用户。

## 地址空间

每台计算机都有一些主存用来保存正在执行的程序。在一个非常简单的操作系统中，仅仅有一个应用程序运行在内存中。为了运行第二个应用程序，需要把第一个应用程序移除才能把第二个程序装入内存。

复杂一些的操作系统会允许多个应用程序同时装入内存中运行。为了防止应用程序之间相互干扰（包括操作系统），需要有某种保护机制。虽然此机制是在硬件中实现，但却是由操作系统控制的。

上述观点涉及对计算机主存的管理和保护。另一种同等重要并与存储器有关的内容是管理进程的地址空间。通常，每个进程有一些可以使用的地址集合，典型值从 0 开始直到某个最大值。一个进程可拥有的最大地址空间小于主存。在这种情况下，即使进程用完其地址空间，内存也会有足够的内存运行该进程。

但是，在许多 32 位或 64 位地址的计算机中，分别有 2^32 或 2^64 字节的地址空间。如果一个进程有比计算机拥有的主存还大的地址空间，而且该进程希望使用全部的内存，那该怎么处理？在早期的计算机中是无法处理的。但是现在有了一种`虚拟内存`的技术，正如前面讲到过的，操作系统可以把部分地址空间装入主存，部分留在磁盘上，并且在需要时来回交换它们。

## 文件

几乎所有操作系统都支持的另一个关键概念就是文件系统。如前所述，操作系统的一项主要功能是屏蔽磁盘和其他 I/O 设备的细节特性，给程序员提供一个良好、清晰的独立于设备的抽象文件模型。**创建文件、删除文件、读文件和写文件** 都需要系统调用。在文件可以读取之前，必须先在磁盘上定位和打开文件，在文件读过之后应该关闭该文件，有关的系统调用则用于完成这类操作。

进程和文件层次都是以树状的结构组织，但这两种树状结构有不少不同之处。一般进程的树状结构层次不深（很少超过三层），而文件系统的树状结构要深一些，通常会到四层甚至五层。进程树层次结构是暂时的，通常最多存在几分钟，而目录层次则可能存在很长时间。进程和文件在权限保护方面也是有区别的。一般来说，父进程能控制和访问子进程，而在文件和目录中通常存在一种机制，使文件所有者之外的其他用户也能访问该文件。

在 UNIX 中，另一个重要的概念是 `特殊文件(special file)`。提供特殊文件是为了使 I/O 设备看起来像文件一般。这样，就像使用系统调用读写文件一样，I/O 设备也可以通过同样的系统调用进行读写。特殊文件有两种，一种是`块儿特殊文件(block special file)` 和 `字符特殊文件(character special file)`。块特殊文件指那些由可随机存取的块组成的设备，如磁盘等。比如打开一个块特殊文件，然后读取第4块，程序可以直接访问设备的第4块而不必考虑存放在该文件的文件系统结构。类似的，字符特殊文件用于打印机、调制解调起和其他接受或输出字符流的设备。按照惯例，特殊文件保存在 `/dev` 目录中。例如，/dev/lp 是打印机。

还有一种与进程和文件相关的特性是管道，`管道(pipe)` 是一种虚文件，他可以连接两个进程

如果 A 和 B 希望通过管道对话，他们必须提前设置管道。当进程 A 相对进程 B 发送数据时，它把数据写到管道上，相当于管道就是输出文件。这样，在 UNIX 中两个进程之间的通信就非常类似于普通文件的读写了。

# 系统调用

我们已经可以看到操作系统提供了两种功能：为用户提供应用程序抽象和管理计算机资源。对于大部分在应用程序和操作系统之间的交互主要是应用程序的抽象，例如创建、写入、读取和删除文件。计算机的资源管理对用户来说基本上是透明的。因此，用户程序和操作系统之间的接口主要是处理抽象。为了真正理解操作系统的行为，我们必须仔细的分析这个接口。

多数现代操作系统都有功能相同但是细节不同的系统调用，引发操作系统的调用依赖于计算机自身的机制，而且必须用汇编代码表达。**任何单 CPU 计算机一次执行执行一条指令**。如果一个进程在用户态下运行用户程序，例如从文件中读取数据。那么如果想要把控制权交给操作系统控制，那么必须执行一个异常指令或者系统调用指令。操作系统紧接着需要参数检查找出所需要的调用进程。然后执行系统调用，把控制权移交给系统调用下面的指令。大致来说，系统调用就像是执行了一个特殊的过程调用，但是只有**系统调用能够进入内核态而过程调用则不能进入内核态**。

为了能够了解具体的调用过程，下面我们以 `read` 方法为例来看一下调用过程。像上面提到的那样，会有三个参数，第一个参数是指定文件、第二个是指向缓冲区、第三个参数是给定需要读取的字节数。就像几乎所有系统调用一样，它通过使用与系统调用相同的名称来调用一个函数库，从而从C程序中调用：read。

```c
count = read(fd,buffer,nbytes);
```

系统调用在 count 中返回实际读出的字节数。这个值通常与 nbytes 相同，但也可能更小。比如在读过程中遇到了文件尾的情况。

如果系统调用不能执行，不管是因为无效的参数还是磁盘错误，count 的值都会被置成 -1，然后在全局变量 `errno` 中放入错误信号。程序应该进场检查系统调用的结果以了解是否出错。

系统调用是通过一系列的步骤实现的，为了更清楚的说明这个概念，我们还以 read 调用为例，在准备系统调用前，首先会把参数压入堆栈，如下所示

![](https://pic.downk.cc/item/5f08301f14195aa594d47cb5.jpg)

C 和 C++ 编译器使用逆序（必须把第一个参数赋值给 printf(格式字符串)，放在堆栈的顶部）。第一个参数和第三个参数都是值调用，但是第二个参数通过引用传递，即传递的是缓冲区的地址（由 & 指示），而不是缓冲的内容。然后是 C 调用系统库的 read 函数，这也是第四步。

在由汇编语言写成的库过程中，一般把系统调用的编号放在操作系统所期望的地方，如寄存器（第五步）。然后执行一个 `TRAP` 指令，将用户态切换到内核态，并在内核中的一个固定地址开始执行第六步。TRAP 指令实际上与过程调用指令非常相似，它们后面都跟随一个来自远处位置的指令，以及供以后使用的一个保存在栈中的返回地址。

TRAP 指令与过程调用指令存在两个方面的不同

- TRAP 指令会改变操作系统的状态，由用户态切换到内核态，而过程调用不改变模式
- 其次，TRAP 指令不能跳转到任意地址上。根据机器的体系结构，要么跳转到一个单固定地址上，或者指令中有一 8 位长的字段，它给定了内存中一张表格的索引，这张表格中含有跳转地址，然后跳转到指定地址上。

跟随在 TRAP 指令后的内核代码开始检查系统调用编号，然后`dispatch`给正确的系统调用处理器，这通常是通过一张由系统调用编号所引用的、指向系统调用处理器的指针表来完成第七步。此时，系统调用处理器运行第八步，一旦系统调用处理器完成工作，控制权会根据 TRAP 指令后面的指令中返回给函数调用库第九步。这个过程接着以通常的过程调用返回的方式，返回到客户应用程序，这是第十步。然后调用完成后，操作系统还必须清除用户堆栈，然后增加`堆栈指针(increment stackpointer)`，用来清除调用 read 之前压入的参数。从而完成整个 read 调用过程。

在上面的第九步中我们说道，控制可能返回 TRAP 指令后面的指令，把控制权再移交给调用者这个过程中，系统调用会发生阻塞，从而避免应用程序继续执行。这么做是有原因的。例如，如果试图读键盘，此时并没有任何输入，那么调用者就必须被阻塞。在这种情形下，操作系统会检查是否有其他可以运行的进程。这样，当有用户输入 时候，进程会提醒操作系统，然后返回第 9 步继续运行。

下面，我们会列出一些常用的 `POSIX` 系统调用，POSIX 系统调用大概有 100 多个，它们之中最重要的一些调用见下表

**进程管理**

| 调用                                 | 说明                     |
| :----------------------------------- | :----------------------- |
| pid = fork()                         | 创建与父进程相同的子进程 |
| pid = waitpid(pid, &statloc,options) | 等待一个子进程终止       |
| s = execve(name,argv,environp)       | 替换一个进程的核心映像   |
| exit(status)                         | 终止进程执行并返回状态   |

**文件管理**

| 调用                               | 说明                         |
| :--------------------------------- | :--------------------------- |
| fd = open(file, how,...)           | 打开一个文件使用读、写       |
| s = close(fd)                      | 关闭一个打开的文件           |
| n = read(fd,buffer,nbytes)         | 把数据从一个文件读到缓冲区中 |
| n = write(fd,buffer,nbytes)        | 把数据从缓冲区写到一个文件中 |
| position = iseek(fd,offset,whence) | 移动文件指针                 |
| s = stat(name,&buf)                | 取得文件状态信息             |

**目录和文件系统管理**

| 调用                         | 说明                                |
| :--------------------------- | :---------------------------------- |
| s = mkdir(nname,mode)        | 创建一个新目录                      |
| s = rmdir(name)              | 删去一个空目录                      |
| s = link(name1,name2)        | 创建一个新目录项 name2,并指向 name1 |
| s = unlink(name)             | 删去一个目录项                      |
| s = mount(special,name,flag) | 安装一个文件系统                    |
| s = umount(special)          | 卸载一个文件系统                    |

**其他**

| 调用                     | 说明                           |
| :----------------------- | :----------------------------- |
| s = chdir(dirname)       | 改变工作目录                   |
| s = chmod(name,mode)     | 修改一个文件的保护位           |
| s = kill(pid, signal)    | 发送信号给进程                 |
| seconds = time(&seconds) | 获取从 1970 年1月1日至今的时间 |

上面的系统调用参数中有一些公共部分，例如 pid 系统进程 id，fd 是文件描述符，n 是字节数，position 是在文件中的偏移量、seconds 是流逝时间。

从宏观角度上看，这些系统调所提供的服务确定了多数操作系统应该具有的功能，下面分别来对不同的系统调用进行解释

## 用于进程管理的系统调用

在 UNIX 中，`fork` 是唯一可以在 POSIX 中创建进程的途径，它创建一个原有进程的副本，包括所有的文件描述符、寄存器等内容。在 fork 之后，原有进程以及副本（父与子）就分开了。在 fork 过程中，所有的变量都有相同的值，虽然父进程的数据通过复制给子进程，但是后续对其中任何一个进程的修改不会影响到另外一个。fork 调用会返回一个值，在子进程中该值为 0 ，并且在父进程中等于子进程的 `进程标识符(Process IDentified,PID)`。使用返回的 PID，就可以看出来哪个是父进程和子进程。

在多数情况下， 在 fork 之后，子进程需要执行和父进程不一样的代码。从终端读取命令，创建一个子进程，等待子进程执行命令，当子进程结束后再读取下一个输入的指令。为了等待子进程完成，父进程需要执行 `waitpid` 系统调用，父进程会等待直至子进程终止（若有多个子进程的话，则直至任何一个子进程终止）。waitpid 可以等待一个特定的子进程，或者通过将第一个参数设为 -1 的方式，等待任何一个比较老的子进程。当 waitpid 完成后，会将第二个参数 `statloc` 所指向的地址设置为子进程的退出状态（正常或异常终止以及退出值）。有各种可使用的选项，它们由第三个参数确定。例如，如果没有已经退出的子进程则立刻返回。

那么 shell 该如何使用 fork 呢？在键入一条命令后，shell 会调用 fork 命令创建一个新的进程。这个子进程会执行用户的指令。通过使用 `execve` 系统调用可以实现系统执行，这个系统调用会引起整个核心映像被一个文件所替代，该文件由第一个参数给定。下面是一个简化版的例子说明 fork、waitpid 和 execve 的使用

```
#define TRUE 1

/* 一直循环下去 */
while(TRUE){			

/* 在屏幕上显示提示符 */
	type_prompt();			
  
  /* 从终端读取输入 */
	read_command(command,parameters)		
  
  /* fork 子进程 */
	if(fork() != 0){								
  
		/* 父代码 */
		/* 等待子进程执行完毕 */
		waitpid(-1, &status, 0);								
	}else{
	
		/* 执行命令 */
		/* 子代码 */
		execve(command,parameters,0)					
	}
}
```

一般情况下，execve 有三个参数：将要执行的文件名称，一个指向变量数组的指针，以及一个指向环境数组的指针。这里对这些参数做一个简要的说明。

先看一个 shell 指令

```
cp file1 file2
```

此命令把 file1 复制到 file2 文件中，在 shell 执行 fork 之后，子进程定位并执行文件拷贝，并将源文件和目标文件的名称传递给它。

cp 的主程序（以及包含其他大多数 C 程序的主程序）包含声明

```
main(argc,argv,envp)
```

其中 argc 是命令行中参数数目的计数，包括程序名称。对于上面的例子，`argc` 是3。第二个参数`argv` 是数组的指针。该数组的元素 i 是指向该命令行第 i 个字符串的指针。在上面的例子中，argv[0] 指向字符串 cp，argv[1] 指向字符串 file1，argv[2] 指向字符串 file2。main 的第三个参数是指向环境的指针，该环境是一个数组，含有 `name = value` 的赋值形式，用以将诸如终端类型以及根目录等信息传送给程序。这些变量通常用来确定用户希望如何完成特定的任务（例如，使用默认打印机）。在上面的例子中，没有环境参数传递给 execve ，所以环境变量是 0 ，所以 execve 的第三个参数为 0 。

可能你觉得 execve 过于复杂，这时候我要鼓励一下你，execve 可能是 POSIX 的全部系统调用中最复杂的一个了，其他都比较简单。作为一个简单的例子，我们再来看一下 `exit` ，这是进程在执行完成后应执行的系统调用。这个系统调用有一个参数，它的退出状态是 0 - 255 之间，它通过 waitpid 系统调用中的 statloc 返回给父级。

UNIX 中的进程将内存划分成三个部分：`text segment,文本区`，例如程序代码，`data segment，数据区`，例如变量，`stack segment`，栈区域。数据地址向上增长而堆栈向下增长，如下图所示

![](https://pic.downk.cc/item/5f4cee45160a154a67f7da37.jpg)

上图能说明三个部分的内存分配情况，夹在中间的是空闲区，也就是未分配的区域，堆栈在需要时自动的挤压空闲区域，不过数据段的扩展是显示地通过系统调用 `brk` 进行的，在数据段扩充后，该系统调用指向一个新地址。但是，这个调用不是 POSIX 标准中定义的，对于存储器的动态分配，鼓励程序员使用 `malloc` 函数，而 malloc 的内部实现则不是一个适合标准化的主题，因为几乎没有程序员直接使用它。

## 用于文件管理的系统调用



[toc]

> [原文章地址](https://mp.weixin.qq.com/s?__biz=MzU2NDg0OTgyMA==&mid=2247485559&idx=1&sn=dfc9973ebf045284c771efa74cfc4ee7&chksm=fc45f584cb327c92bf4f5854c5dca343bc35a30bf385fa42b4d8d3f0d08ea48d59416dc9a7dc&token=1981249032&lang=zh_CN#rd)

# 网络编程

网络编程是基于client-server模型。

互联网络的关键是在每个主机和路由器上运行一个协议软件，这个软件基于统一的协议分配地址，并且在电缆上编码位和将位封装成帧。通过一种统一的将数据位捆扎成不连续的片（包）的统一方式，从而消除了差异。一个包是由包头和有效载荷组成，包头包括包的大小和源目的地址，有效载荷包括从源主机发出的数据位。

![](https://pic.downk.cc/item/5f4cf328160a154a67fc1287.jpg)

2.注意协议软件对数据的封装是两层的，添加互联网包头（ip）和LAN1的帧头（MAC），包头负责寻找到主机B，LAN1帧头负责寻址到路由器，传输给LAN2适配器。LAN1帧的有效载荷是一个互联网包，互联网包的有效载荷是实际数据。

4.路由器接到LAN1适配器接受到的帧后，从包头里提取目的网络地址dst_ip，并将它作为路由表的索引确定向哪转发这个包，并且剥离LAN1的帧头，重新对互联网包进行封装，添加寻址到的LAN2帧头。

### 套接字

一个套接字是连接的一个端点。每个套接字都有相应的套接字地址。用地址：端口表示。

当客户端发送一个网络请求时或者一个进程间请求（连接请求）。内核会临时为客户端的进程分配一个端口（临时端口），而服务器上提供服务的端口一般是默认通用的，例如ssh服务的22端口，web服务的80端口，邮件服务的25端口。

一个连接是由两端的套接字地址唯一确定的。

对于内核来说，套接字地址是一个端口，对于linux应用程序来说，套接字就是一个有相应描述符打开的文件，向文件传输或者接受数据。



### WEB服务器

客户端和web服务器是基于超文本协议（http）传输数据。

<b>http</b>

<a href='tkhfree.github.io'>互联网跳转指针连接</a>

web服务器以两种方式向客户端提供内容：

静态内容：磁盘文件

动态内容：运行一个可执行文件

#### web内容

MIME类型：

text/html html页面

text/plain 无格式文本

application/postscript postscript文档

image/gif 二进制图像

image/png 二进制图像

image/jpeg 二进制图像

#### HTTP事务

##### HTTP请求

http请求包括一个文本请求行，后面跟随0个或者多个请求报头，在跟随一个空的文本行终止包头列表

```http
GET / HTTP/1.1 #请求行
Host: www.baidu.com #请求报头
                    #空的
```

请求行的形式是method URI version

method：GET DELETE POST OPTIONAL PUT HEADER

URI是URL的后缀，包括文件名和可选的参数

version是HTTP的版本，一般只有1.0和1.1，互相兼容



请求报头为服务器提供了额外的信息，例如浏览器的商标或者浏览器可以理解的MIME类型。请求报头格式：

header-name：header-data

##### HTTP响应

http响应包括一个响应行，跟随多个响应报头，再跟随一个终止报头的空行，在跟随响应主体

响应行格式是version status-code status-message

```http
HTTP/1.0 200 ok #响应行
MIME-VERSION1:1.0 #响应报头
DATE:MON, 8 JAN 2000 05:05:05 GMT
SERVER:APACHE-COyote/1.1
Content-Type:text/html
Content-Length:55555 #响应报头
                     #空行，终止报头
<html>               #响应主体，response body
...
</html>
```

#### 服务动态内容

客户端如何将参数传递给服务器？服务器如何传递参数给它的子进程？服务器如何将子进程生成内容所需的其他信息传递给子进程？子进程将输出传送到哪里？

##### CGI(通用网关接口common gateway interface)

1. 客户端将参数传递给服务器

   GET请求参数放在URI里吗？分割路径和参数，&分割参数

   POST请求参数放在主体中，这样的请求会把参数隐藏起来

2. 服务器将参数传递给子进程

   服务器接受到 

   GET  /cgi-bin/adder?15000&213  HTTP/1.1

   之后，它调用fork创建子进程，并且执行execve在子进程的上下文中执行/cgi-bin/adder程序，在调用execve之前，子进程将CGI环境变量QUERY_STRING设置为15000&213，adder是一个标准的遵循CGI格式的函数

3. 服务器如何将其他信息传递给子进程

   CGI程序可以在运行时设置环境变量

4. 子进程将输出传送到哪里

   CGI程序将他的输出发送到标准输出，在子进程加载并运行CGI之前，使用Linux dup2函数将标准输出重定向到和客户端相连接的已连接描述符，因此标准输出的的内容会直接传输到客户端

   子进程负责生成content-type和content-length响应报头以及终止报头的空行

